{"ast":null,"code":"'use strict';\n/*\n * Displays a helpful message and the source of\n * the format when it is invalid.\n */\n\nclass InvalidFormatError extends Error {\n  constructor(formatFn) {\n    super(`Format functions must be synchronous taking a two arguments: (info, opts)\nFound: ${formatFn.toString().split('\\n')[0]}\\n`);\n    Error.captureStackTrace(this, InvalidFormatError);\n  }\n\n}\n/*\n * function format (formatFn)\n * Returns a create function for the `formatFn`.\n */\n\n\nmodule.exports = formatFn => {\n  if (formatFn.length > 2) {\n    throw new InvalidFormatError(formatFn);\n  }\n  /*\n   * function Format (options)\n   * Base prototype which calls a `_format`\n   * function and pushes the result.\n   */\n\n\n  function Format() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.options = options;\n  }\n\n  Format.prototype.transform = formatFn; //\n  // Create a function which returns new instances of\n  // FormatWrap for simple syntax like:\n  //\n  // require('winston').formats.json();\n  //\n\n  function createFormatWrap(opts) {\n    return new Format(opts);\n  } //\n  // Expose the FormatWrap through the create function\n  // for testability.\n  //\n\n\n  createFormatWrap.Format = Format;\n  return createFormatWrap;\n};","map":{"version":3,"names":["InvalidFormatError","Error","constructor","formatFn","toString","split","captureStackTrace","module","exports","length","Format","options","prototype","transform","createFormatWrap","opts"],"sources":["D:/Other Files/tktnew/eMandate/client/node_modules/logform/format.js"],"sourcesContent":["'use strict';\n\n/*\n * Displays a helpful message and the source of\n * the format when it is invalid.\n */\nclass InvalidFormatError extends Error {\n  constructor(formatFn) {\n    super(`Format functions must be synchronous taking a two arguments: (info, opts)\nFound: ${formatFn.toString().split('\\n')[0]}\\n`);\n\n    Error.captureStackTrace(this, InvalidFormatError);\n  }\n}\n\n/*\n * function format (formatFn)\n * Returns a create function for the `formatFn`.\n */\nmodule.exports = formatFn => {\n  if (formatFn.length > 2) {\n    throw new InvalidFormatError(formatFn);\n  }\n\n  /*\n   * function Format (options)\n   * Base prototype which calls a `_format`\n   * function and pushes the result.\n   */\n  function Format(options = {}) {\n    this.options = options;\n  }\n\n  Format.prototype.transform = formatFn;\n\n  //\n  // Create a function which returns new instances of\n  // FormatWrap for simple syntax like:\n  //\n  // require('winston').formats.json();\n  //\n  function createFormatWrap(opts) {\n    return new Format(opts);\n  }\n\n  //\n  // Expose the FormatWrap through the create function\n  // for testability.\n  //\n  createFormatWrap.Format = Format;\n  return createFormatWrap;\n};\n"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;;AACA,MAAMA,kBAAN,SAAiCC,KAAjC,CAAuC;EACrCC,WAAW,CAACC,QAAD,EAAW;IACpB,MAAO;AACX,SAASA,QAAQ,CAACC,QAAT,GAAoBC,KAApB,CAA0B,IAA1B,EAAgC,CAAhC,CAAmC,IADxC;IAGAJ,KAAK,CAACK,iBAAN,CAAwB,IAAxB,EAA8BN,kBAA9B;EACD;;AANoC;AASvC;AACA;AACA;AACA;;;AACAO,MAAM,CAACC,OAAP,GAAiBL,QAAQ,IAAI;EAC3B,IAAIA,QAAQ,CAACM,MAAT,GAAkB,CAAtB,EAAyB;IACvB,MAAM,IAAIT,kBAAJ,CAAuBG,QAAvB,CAAN;EACD;EAED;AACF;AACA;AACA;AACA;;;EACE,SAASO,MAAT,GAA8B;IAAA,IAAdC,OAAc,uEAAJ,EAAI;IAC5B,KAAKA,OAAL,GAAeA,OAAf;EACD;;EAEDD,MAAM,CAACE,SAAP,CAAiBC,SAAjB,GAA6BV,QAA7B,CAd2B,CAgB3B;EACA;EACA;EACA;EACA;EACA;;EACA,SAASW,gBAAT,CAA0BC,IAA1B,EAAgC;IAC9B,OAAO,IAAIL,MAAJ,CAAWK,IAAX,CAAP;EACD,CAxB0B,CA0B3B;EACA;EACA;EACA;;;EACAD,gBAAgB,CAACJ,MAAjB,GAA0BA,MAA1B;EACA,OAAOI,gBAAP;AACD,CAhCD"},"metadata":{},"sourceType":"script"}