{"ast":null,"code":"'use strict';\n\nconst events = require('events');\n\nconst cronParser = require('cron-parser');\n\nconst CronDate = require('cron-parser/lib/date');\n\nconst sorted = require('sorted-array-functions');\n\nconst {\n  scheduleNextRecurrence,\n  scheduleInvocation,\n  cancelInvocation,\n  RecurrenceRule,\n  sorter,\n  Invocation\n} = require('./Invocation');\n\nconst {\n  isValidDate\n} = require('./utils/dateUtils');\n\nconst scheduledJobs = {};\nlet anonJobCounter = 0;\n\nfunction resolveAnonJobName() {\n  const now = new Date();\n\n  if (anonJobCounter === Number.MAX_SAFE_INTEGER) {\n    anonJobCounter = 0;\n  }\n\n  anonJobCounter++;\n  return `<Anonymous Job ${anonJobCounter} ${now.toISOString()}>`;\n}\n\nfunction Job(name, job, callback) {\n  // setup a private pendingInvocations variable\n  this.pendingInvocations = []; //setup a private number of invocations variable\n\n  let triggeredJobs = 0; // Set scope vars\n\n  const jobName = name && typeof name === 'string' ? name : resolveAnonJobName();\n  this.job = name && typeof name === 'function' ? name : job; // Make sure callback is actually a callback\n\n  if (this.job === name) {\n    // Name wasn't provided and maybe a callback is there\n    this.callback = typeof job === 'function' ? job : false;\n  } else {\n    // Name was provided, and maybe a callback is there\n    this.callback = typeof callback === 'function' ? callback : false;\n  } // task count\n\n\n  this.running = 0; // Check for generator\n\n  if (typeof this.job === 'function' && this.job.prototype && this.job.prototype.next) {\n    this.job = function () {\n      return this.next().value;\n    }.bind(this.job.call(this));\n  } // define properties\n\n\n  Object.defineProperty(this, 'name', {\n    value: jobName,\n    writable: false,\n    enumerable: true\n  }); // method that require private access\n\n  this.trackInvocation = function (invocation) {\n    // add to our invocation list\n    sorted.add(this.pendingInvocations, invocation, sorter);\n    return true;\n  };\n\n  this.stopTrackingInvocation = function (invocation) {\n    const invIdx = this.pendingInvocations.indexOf(invocation);\n\n    if (invIdx > -1) {\n      this.pendingInvocations.splice(invIdx, 1);\n      return true;\n    }\n\n    return false;\n  };\n\n  this.triggeredJobs = function () {\n    return triggeredJobs;\n  };\n\n  this.setTriggeredJobs = function (triggeredJob) {\n    triggeredJobs = triggeredJob;\n  };\n\n  this.deleteFromSchedule = function () {\n    deleteScheduledJob(this.name);\n  };\n\n  this.cancel = function (reschedule) {\n    reschedule = typeof reschedule == 'boolean' ? reschedule : false;\n    let inv, newInv;\n    const newInvs = [];\n\n    for (let j = 0; j < this.pendingInvocations.length; j++) {\n      inv = this.pendingInvocations[j];\n      cancelInvocation(inv);\n\n      if (reschedule && (inv.recurrenceRule.recurs || inv.recurrenceRule.next)) {\n        newInv = scheduleNextRecurrence(inv.recurrenceRule, this, inv.fireDate, inv.endDate);\n\n        if (newInv !== null) {\n          newInvs.push(newInv);\n        }\n      }\n    }\n\n    this.pendingInvocations = [];\n\n    for (let k = 0; k < newInvs.length; k++) {\n      this.trackInvocation(newInvs[k]);\n    } // remove from scheduledJobs if reschedule === false\n\n\n    if (!reschedule) {\n      this.deleteFromSchedule();\n    }\n\n    return true;\n  };\n\n  this.cancelNext = function (reschedule) {\n    reschedule = typeof reschedule == 'boolean' ? reschedule : true;\n\n    if (!this.pendingInvocations.length) {\n      return false;\n    }\n\n    let newInv;\n    const nextInv = this.pendingInvocations.shift();\n    cancelInvocation(nextInv);\n\n    if (reschedule && (nextInv.recurrenceRule.recurs || nextInv.recurrenceRule.next)) {\n      newInv = scheduleNextRecurrence(nextInv.recurrenceRule, this, nextInv.fireDate, nextInv.endDate);\n\n      if (newInv !== null) {\n        this.trackInvocation(newInv);\n      }\n    }\n\n    return true;\n  };\n\n  this.reschedule = function (spec) {\n    let inv;\n    const invocationsToCancel = this.pendingInvocations.slice();\n\n    for (let j = 0; j < invocationsToCancel.length; j++) {\n      inv = invocationsToCancel[j];\n      cancelInvocation(inv);\n    }\n\n    this.pendingInvocations = [];\n\n    if (this.schedule(spec)) {\n      this.setTriggeredJobs(0);\n      return true;\n    } else {\n      this.pendingInvocations = invocationsToCancel;\n      return false;\n    }\n  };\n\n  this.nextInvocation = function () {\n    if (!this.pendingInvocations.length) {\n      return null;\n    }\n\n    return this.pendingInvocations[0].fireDate;\n  };\n}\n\nObject.setPrototypeOf(Job.prototype, events.EventEmitter.prototype);\n\nJob.prototype.invoke = function (fireDate) {\n  this.setTriggeredJobs(this.triggeredJobs() + 1);\n  return this.job(fireDate);\n};\n\nJob.prototype.runOnDate = function (date) {\n  return this.schedule(date);\n};\n\nJob.prototype.schedule = function (spec) {\n  const self = this;\n  let success = false;\n  let inv;\n  let start;\n  let end;\n  let tz; // save passed-in value before 'spec' is replaced\n\n  if (typeof spec === 'object' && 'tz' in spec) {\n    tz = spec.tz;\n  }\n\n  if (typeof spec === 'object' && spec.rule) {\n    start = spec.start || undefined;\n    end = spec.end || undefined;\n    spec = spec.rule;\n\n    if (start) {\n      if (!(start instanceof Date)) {\n        start = new Date(start);\n      }\n\n      start = new CronDate(start, tz);\n\n      if (!isValidDate(start) || start.getTime() < Date.now()) {\n        start = undefined;\n      }\n    }\n\n    if (end && !(end instanceof Date) && !isValidDate(end = new Date(end))) {\n      end = undefined;\n    }\n\n    if (end) {\n      end = new CronDate(end, tz);\n    }\n  }\n\n  try {\n    const res = cronParser.parseExpression(spec, {\n      currentDate: start,\n      tz: tz\n    });\n    inv = scheduleNextRecurrence(res, self, start, end);\n\n    if (inv !== null) {\n      success = self.trackInvocation(inv);\n    }\n  } catch (err) {\n    const type = typeof spec;\n\n    if (type === 'string' || type === 'number') {\n      spec = new Date(spec);\n    }\n\n    if (spec instanceof Date && isValidDate(spec)) {\n      spec = new CronDate(spec);\n      self.isOneTimeJob = true;\n\n      if (spec.getTime() >= Date.now()) {\n        inv = new Invocation(self, spec);\n        scheduleInvocation(inv);\n        success = self.trackInvocation(inv);\n      }\n    } else if (type === 'object') {\n      self.isOneTimeJob = false;\n\n      if (!(spec instanceof RecurrenceRule)) {\n        const r = new RecurrenceRule();\n\n        if ('year' in spec) {\n          r.year = spec.year;\n        }\n\n        if ('month' in spec) {\n          r.month = spec.month;\n        }\n\n        if ('date' in spec) {\n          r.date = spec.date;\n        }\n\n        if ('dayOfWeek' in spec) {\n          r.dayOfWeek = spec.dayOfWeek;\n        }\n\n        if ('hour' in spec) {\n          r.hour = spec.hour;\n        }\n\n        if ('minute' in spec) {\n          r.minute = spec.minute;\n        }\n\n        if ('second' in spec) {\n          r.second = spec.second;\n        }\n\n        spec = r;\n      }\n\n      spec.tz = tz;\n      inv = scheduleNextRecurrence(spec, self, start, end);\n\n      if (inv !== null) {\n        success = self.trackInvocation(inv);\n      }\n    }\n  }\n\n  scheduledJobs[this.name] = this;\n  return success;\n};\n\nfunction deleteScheduledJob(name) {\n  if (name) {\n    delete scheduledJobs[name];\n  }\n}\n\nmodule.exports = {\n  Job,\n  deleteScheduledJob,\n  scheduledJobs\n};","map":{"version":3,"names":["events","require","cronParser","CronDate","sorted","scheduleNextRecurrence","scheduleInvocation","cancelInvocation","RecurrenceRule","sorter","Invocation","isValidDate","scheduledJobs","anonJobCounter","resolveAnonJobName","now","Date","Number","MAX_SAFE_INTEGER","toISOString","Job","name","job","callback","pendingInvocations","triggeredJobs","jobName","running","prototype","next","value","bind","call","Object","defineProperty","writable","enumerable","trackInvocation","invocation","add","stopTrackingInvocation","invIdx","indexOf","splice","setTriggeredJobs","triggeredJob","deleteFromSchedule","deleteScheduledJob","cancel","reschedule","inv","newInv","newInvs","j","length","recurrenceRule","recurs","fireDate","endDate","push","k","cancelNext","nextInv","shift","spec","invocationsToCancel","slice","schedule","nextInvocation","setPrototypeOf","EventEmitter","invoke","runOnDate","date","self","success","start","end","tz","rule","undefined","getTime","res","parseExpression","currentDate","err","type","isOneTimeJob","r","year","month","dayOfWeek","hour","minute","second","module","exports"],"sources":["D:/Other Files/tktnew/eMandate/client/node_modules/node-schedule/lib/Job.js"],"sourcesContent":["'use strict';\n\nconst events = require('events')\nconst cronParser = require('cron-parser')\nconst CronDate = require('cron-parser/lib/date')\nconst sorted = require('sorted-array-functions')\n\nconst { scheduleNextRecurrence, scheduleInvocation, cancelInvocation, RecurrenceRule, sorter, Invocation } = require('./Invocation')\nconst { isValidDate } = require('./utils/dateUtils')\n\nconst scheduledJobs = {};\n\nlet anonJobCounter = 0;\nfunction resolveAnonJobName() {\n  const now = new Date()\n  if (anonJobCounter === Number.MAX_SAFE_INTEGER) {\n    anonJobCounter = 0\n  }\n  anonJobCounter++\n\n  return `<Anonymous Job ${anonJobCounter} ${now.toISOString()}>`\n}\n\nfunction Job(name, job, callback) {\n  // setup a private pendingInvocations variable\n  this.pendingInvocations = [];\n\n  //setup a private number of invocations variable\n  let triggeredJobs = 0;\n\n  // Set scope vars\n  const jobName = name && typeof name === 'string' ? name : resolveAnonJobName();\n  this.job = name && typeof name === 'function' ? name : job;\n\n  // Make sure callback is actually a callback\n  if (this.job === name) {\n    // Name wasn't provided and maybe a callback is there\n    this.callback = typeof job === 'function' ? job : false;\n  } else {\n    // Name was provided, and maybe a callback is there\n    this.callback = typeof callback === 'function' ? callback : false;\n  }\n\n  // task count\n  this.running = 0;\n\n  // Check for generator\n  if (typeof this.job === 'function' &&\n    this.job.prototype &&\n    this.job.prototype.next) {\n    this.job = function() {\n      return this.next().value;\n    }.bind(this.job.call(this));\n  }\n\n  // define properties\n  Object.defineProperty(this, 'name', {\n    value: jobName,\n    writable: false,\n    enumerable: true\n  });\n\n  // method that require private access\n  this.trackInvocation = function(invocation) {\n    // add to our invocation list\n    sorted.add(this.pendingInvocations, invocation, sorter);\n    return true;\n  };\n  this.stopTrackingInvocation = function(invocation) {\n    const invIdx = this.pendingInvocations.indexOf(invocation);\n    if (invIdx > -1) {\n      this.pendingInvocations.splice(invIdx, 1);\n      return true;\n    }\n\n    return false;\n  };\n  this.triggeredJobs = function() {\n    return triggeredJobs;\n  };\n  this.setTriggeredJobs = function(triggeredJob) {\n    triggeredJobs = triggeredJob;\n  };\n  this.deleteFromSchedule = function() {\n    deleteScheduledJob(this.name)\n  };\n  this.cancel = function(reschedule) {\n    reschedule = (typeof reschedule == 'boolean') ? reschedule : false;\n\n    let inv, newInv;\n    const newInvs = [];\n    for (let j = 0; j < this.pendingInvocations.length; j++) {\n      inv = this.pendingInvocations[j];\n\n      cancelInvocation(inv);\n\n      if (reschedule && (inv.recurrenceRule.recurs || inv.recurrenceRule.next)) {\n        newInv = scheduleNextRecurrence(inv.recurrenceRule, this, inv.fireDate, inv.endDate);\n        if (newInv !== null) {\n          newInvs.push(newInv);\n        }\n      }\n    }\n\n    this.pendingInvocations = [];\n\n    for (let k = 0; k < newInvs.length; k++) {\n      this.trackInvocation(newInvs[k]);\n    }\n\n    // remove from scheduledJobs if reschedule === false\n    if (!reschedule) {\n      this.deleteFromSchedule()\n    }\n\n    return true;\n  };\n  this.cancelNext = function(reschedule) {\n    reschedule = (typeof reschedule == 'boolean') ? reschedule : true;\n\n    if (!this.pendingInvocations.length) {\n      return false;\n    }\n\n    let newInv;\n    const nextInv = this.pendingInvocations.shift();\n\n    cancelInvocation(nextInv);\n\n    if (reschedule && (nextInv.recurrenceRule.recurs || nextInv.recurrenceRule.next)) {\n      newInv = scheduleNextRecurrence(nextInv.recurrenceRule, this, nextInv.fireDate, nextInv.endDate);\n      if (newInv !== null) {\n        this.trackInvocation(newInv);\n      }\n    }\n\n    return true;\n  };\n  this.reschedule = function(spec) {\n    let inv;\n    const invocationsToCancel = this.pendingInvocations.slice();\n\n    for (let j = 0; j < invocationsToCancel.length; j++) {\n      inv = invocationsToCancel[j];\n\n      cancelInvocation(inv);\n    }\n\n    this.pendingInvocations = [];\n\n    if (this.schedule(spec)) {\n      this.setTriggeredJobs(0);\n      return true;\n    } else {\n      this.pendingInvocations = invocationsToCancel;\n      return false;\n    }\n  };\n  this.nextInvocation = function() {\n    if (!this.pendingInvocations.length) {\n      return null;\n    }\n    return this.pendingInvocations[0].fireDate;\n  };\n}\n\nObject.setPrototypeOf(Job.prototype, events.EventEmitter.prototype);\n\nJob.prototype.invoke = function(fireDate) {\n  this.setTriggeredJobs(this.triggeredJobs() + 1);\n  return this.job(fireDate);\n};\n\nJob.prototype.runOnDate = function(date) {\n  return this.schedule(date);\n};\n\nJob.prototype.schedule = function(spec) {\n  const self = this;\n  let success = false;\n  let inv;\n  let start;\n  let end;\n  let tz;\n\n  // save passed-in value before 'spec' is replaced\n  if (typeof spec === 'object' && 'tz' in spec) {\n    tz = spec.tz;\n  }\n\n  if (typeof spec === 'object' && spec.rule) {\n    start = spec.start || undefined;\n    end = spec.end || undefined;\n    spec = spec.rule;\n\n    if (start) {\n      if (!(start instanceof Date)) {\n        start = new Date(start);\n      }\n\n      start = new CronDate(start, tz);\n      if (!isValidDate(start) || start.getTime() < Date.now()) {\n        start = undefined;\n      }\n    }\n\n    if (end && !(end instanceof Date) && !isValidDate(end = new Date(end))) {\n      end = undefined;\n    }\n\n    if (end) {\n      end = new CronDate(end, tz);\n    }\n  }\n\n  try {\n    const res = cronParser.parseExpression(spec, {currentDate: start, tz: tz});\n    inv = scheduleNextRecurrence(res, self, start, end);\n    if (inv !== null) {\n      success = self.trackInvocation(inv);\n    }\n  } catch (err) {\n    const type = typeof spec;\n    if ((type === 'string') || (type === 'number')) {\n      spec = new Date(spec);\n    }\n\n    if ((spec instanceof Date) && (isValidDate(spec))) {\n      spec = new CronDate(spec);\n      self.isOneTimeJob = true;\n      if (spec.getTime() >= Date.now()) {\n        inv = new Invocation(self, spec);\n        scheduleInvocation(inv);\n        success = self.trackInvocation(inv);\n      }\n    } else if (type === 'object') {\n      self.isOneTimeJob = false;\n      if (!(spec instanceof RecurrenceRule)) {\n        const r = new RecurrenceRule();\n        if ('year' in spec) {\n          r.year = spec.year;\n        }\n        if ('month' in spec) {\n          r.month = spec.month;\n        }\n        if ('date' in spec) {\n          r.date = spec.date;\n        }\n        if ('dayOfWeek' in spec) {\n          r.dayOfWeek = spec.dayOfWeek;\n        }\n        if ('hour' in spec) {\n          r.hour = spec.hour;\n        }\n        if ('minute' in spec) {\n          r.minute = spec.minute;\n        }\n        if ('second' in spec) {\n          r.second = spec.second;\n        }\n\n        spec = r;\n      }\n\n      spec.tz = tz;\n      inv = scheduleNextRecurrence(spec, self, start, end);\n      if (inv !== null) {\n        success = self.trackInvocation(inv);\n      }\n    }\n  }\n\n  scheduledJobs[this.name] = this;\n  return success;\n};\n\nfunction deleteScheduledJob(name) {\n  if (name) {\n    delete scheduledJobs[name];\n  }\n}\n\nmodule.exports = {\n  Job,\n  deleteScheduledJob,\n  scheduledJobs\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}