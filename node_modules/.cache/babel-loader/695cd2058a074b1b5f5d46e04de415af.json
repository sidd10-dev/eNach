{"ast":null,"code":"'use strict';\n\nconst lt = require('long-timeout');\n\nconst CronDate = require('cron-parser/lib/date');\n\nconst sorted = require('sorted-array-functions');\n\nconst invocations = [];\nlet currentInvocation = null;\n/* DoesntRecur rule */\n\nconst DoesntRecur = new RecurrenceRule();\nDoesntRecur.recurs = false;\n/* Invocation object */\n\nfunction Invocation(job, fireDate, recurrenceRule, endDate) {\n  this.job = job;\n  this.fireDate = fireDate;\n  this.endDate = endDate;\n  this.recurrenceRule = recurrenceRule || DoesntRecur;\n  this.timerID = null;\n}\n\nfunction sorter(a, b) {\n  return a.fireDate.getTime() - b.fireDate.getTime();\n}\n/* Range object */\n\n\nfunction Range(start, end, step) {\n  this.start = start || 0;\n  this.end = end || 60;\n  this.step = step || 1;\n}\n\nRange.prototype.contains = function (val) {\n  if (this.step === null || this.step === 1) {\n    return val >= this.start && val <= this.end;\n  } else {\n    for (let i = this.start; i < this.end; i += this.step) {\n      if (i === val) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n};\n/* RecurrenceRule object */\n\n/*\n  Interpreting each property:\n  null - any value is valid\n  number - fixed value\n  Range - value must fall in range\n  array - value must validate against any item in list\n\n  NOTE: Cron months are 1-based, but RecurrenceRule months are 0-based.\n*/\n\n\nfunction RecurrenceRule(year, month, date, dayOfWeek, hour, minute, second) {\n  this.recurs = true;\n  this.year = year == null ? null : year;\n  this.month = month == null ? null : month;\n  this.date = date == null ? null : date;\n  this.dayOfWeek = dayOfWeek == null ? null : dayOfWeek;\n  this.hour = hour == null ? null : hour;\n  this.minute = minute == null ? null : minute;\n  this.second = second == null ? 0 : second;\n}\n\nRecurrenceRule.prototype.isValid = function () {\n  function isValidType(num) {\n    if (Array.isArray(num) || num instanceof Array) {\n      return num.every(function (e) {\n        return isValidType(e);\n      });\n    }\n\n    return !(Number.isNaN(Number(num)) && !(num instanceof Range));\n  }\n\n  if (this.month !== null && (this.month < 0 || this.month > 11 || !isValidType(this.month))) {\n    return false;\n  }\n\n  if (this.dayOfWeek !== null && (this.dayOfWeek < 0 || this.dayOfWeek > 6 || !isValidType(this.dayOfWeek))) {\n    return false;\n  }\n\n  if (this.hour !== null && (this.hour < 0 || this.hour > 23 || !isValidType(this.hour))) {\n    return false;\n  }\n\n  if (this.minute !== null && (this.minute < 0 || this.minute > 59 || !isValidType(this.minute))) {\n    return false;\n  }\n\n  if (this.second !== null && (this.second < 0 || this.second > 59 || !isValidType(this.second))) {\n    return false;\n  }\n\n  if (this.date !== null) {\n    if (!isValidType(this.date)) {\n      return false;\n    }\n\n    switch (this.month) {\n      case 3:\n      case 5:\n      case 8:\n      case 10:\n        if (this.date < 1 || this.date > 30) {\n          return false;\n        }\n\n        break;\n\n      case 1:\n        if (this.date < 1 || this.date > 29) {\n          return false;\n        }\n\n        break;\n\n      default:\n        if (this.date < 1 || this.date > 31) {\n          return false;\n        }\n\n    }\n  }\n\n  return true;\n};\n\nRecurrenceRule.prototype.nextInvocationDate = function (base) {\n  const next = this._nextInvocationDate(base);\n\n  return next ? next.toDate() : null;\n};\n\nRecurrenceRule.prototype._nextInvocationDate = function (base) {\n  base = base instanceof CronDate || base instanceof Date ? base : new Date();\n\n  if (!this.recurs) {\n    return null;\n  }\n\n  if (!this.isValid()) {\n    return null;\n  }\n\n  const now = new CronDate(Date.now(), this.tz);\n  let fullYear = now.getFullYear();\n\n  if (this.year !== null && typeof this.year == 'number' && this.year < fullYear) {\n    return null;\n  }\n\n  let next = new CronDate(base.getTime(), this.tz);\n  next.addSecond();\n\n  while (true) {\n    if (this.year !== null) {\n      fullYear = next.getFullYear();\n\n      if (typeof this.year == 'number' && this.year < fullYear) {\n        next = null;\n        break;\n      }\n\n      if (!recurMatch(fullYear, this.year)) {\n        next.addYear();\n        next.setMonth(0);\n        next.setDate(1);\n        next.setHours(0);\n        next.setMinutes(0);\n        next.setSeconds(0);\n        continue;\n      }\n    }\n\n    if (this.month != null && !recurMatch(next.getMonth(), this.month)) {\n      next.addMonth();\n      continue;\n    }\n\n    if (this.date != null && !recurMatch(next.getDate(), this.date)) {\n      next.addDay();\n      continue;\n    }\n\n    if (this.dayOfWeek != null && !recurMatch(next.getDay(), this.dayOfWeek)) {\n      next.addDay();\n      continue;\n    }\n\n    if (this.hour != null && !recurMatch(next.getHours(), this.hour)) {\n      next.addHour();\n      continue;\n    }\n\n    if (this.minute != null && !recurMatch(next.getMinutes(), this.minute)) {\n      next.addMinute();\n      continue;\n    }\n\n    if (this.second != null && !recurMatch(next.getSeconds(), this.second)) {\n      next.addSecond();\n      continue;\n    }\n\n    break;\n  }\n\n  return next;\n};\n\nfunction recurMatch(val, matcher) {\n  if (matcher == null) {\n    return true;\n  }\n\n  if (typeof matcher === 'number') {\n    return val === matcher;\n  } else if (typeof matcher === 'string') {\n    return val === Number(matcher);\n  } else if (matcher instanceof Range) {\n    return matcher.contains(val);\n  } else if (Array.isArray(matcher) || matcher instanceof Array) {\n    for (let i = 0; i < matcher.length; i++) {\n      if (recurMatch(val, matcher[i])) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n/* Date-based scheduler */\n\n\nfunction runOnDate(date, job) {\n  const now = Date.now();\n  const then = date.getTime();\n  return lt.setTimeout(function () {\n    if (then > Date.now()) runOnDate(date, job);else job();\n  }, then < now ? 0 : then - now);\n}\n\nfunction scheduleInvocation(invocation) {\n  sorted.add(invocations, invocation, sorter);\n  prepareNextInvocation();\n  const date = invocation.fireDate instanceof CronDate ? invocation.fireDate.toDate() : invocation.fireDate;\n  invocation.job.emit('scheduled', date);\n}\n\nfunction prepareNextInvocation() {\n  if (invocations.length > 0 && currentInvocation !== invocations[0]) {\n    if (currentInvocation !== null) {\n      lt.clearTimeout(currentInvocation.timerID);\n      currentInvocation.timerID = null;\n      currentInvocation = null;\n    }\n\n    currentInvocation = invocations[0];\n    const job = currentInvocation.job;\n    const cinv = currentInvocation;\n    currentInvocation.timerID = runOnDate(currentInvocation.fireDate, function () {\n      currentInvocationFinished();\n\n      if (job.callback) {\n        job.callback();\n      }\n\n      if (cinv.recurrenceRule.recurs || cinv.recurrenceRule._endDate === null) {\n        const inv = scheduleNextRecurrence(cinv.recurrenceRule, cinv.job, cinv.fireDate, cinv.endDate);\n\n        if (inv !== null) {\n          inv.job.trackInvocation(inv);\n        }\n      }\n\n      job.stopTrackingInvocation(cinv);\n\n      try {\n        const result = job.invoke(cinv.fireDate instanceof CronDate ? cinv.fireDate.toDate() : cinv.fireDate);\n        job.emit('run');\n        job.running += 1;\n\n        if (result instanceof Promise) {\n          result.then(function (value) {\n            job.emit('success', value);\n            job.running -= 1;\n          }).catch(function (err) {\n            job.emit('error', err);\n            job.running -= 1;\n          });\n        } else {\n          job.emit('success', result);\n          job.running -= 1;\n        }\n      } catch (err) {\n        job.emit('error', err);\n        job.running -= 1;\n      }\n\n      if (job.isOneTimeJob) {\n        job.deleteFromSchedule();\n      }\n    });\n  }\n}\n\nfunction currentInvocationFinished() {\n  invocations.shift();\n  currentInvocation = null;\n  prepareNextInvocation();\n}\n\nfunction cancelInvocation(invocation) {\n  const idx = invocations.indexOf(invocation);\n\n  if (idx > -1) {\n    invocations.splice(idx, 1);\n\n    if (invocation.timerID !== null) {\n      lt.clearTimeout(invocation.timerID);\n    }\n\n    if (currentInvocation === invocation) {\n      currentInvocation = null;\n    }\n\n    invocation.job.emit('canceled', invocation.fireDate);\n    prepareNextInvocation();\n  }\n}\n/* Recurrence scheduler */\n\n\nfunction scheduleNextRecurrence(rule, job, prevDate, endDate) {\n  prevDate = prevDate instanceof CronDate ? prevDate : new CronDate();\n  const date = rule instanceof RecurrenceRule ? rule._nextInvocationDate(prevDate) : rule.next();\n\n  if (date === null) {\n    return null;\n  }\n\n  if (endDate instanceof CronDate && date.getTime() > endDate.getTime()) {\n    return null;\n  }\n\n  const inv = new Invocation(job, date, rule, endDate);\n  scheduleInvocation(inv);\n  return inv;\n}\n\nmodule.exports = {\n  Range,\n  RecurrenceRule,\n  Invocation,\n  cancelInvocation,\n  scheduleInvocation,\n  scheduleNextRecurrence,\n  sorter,\n  _invocations: invocations\n};","map":{"version":3,"names":["lt","require","CronDate","sorted","invocations","currentInvocation","DoesntRecur","RecurrenceRule","recurs","Invocation","job","fireDate","recurrenceRule","endDate","timerID","sorter","a","b","getTime","Range","start","end","step","prototype","contains","val","i","year","month","date","dayOfWeek","hour","minute","second","isValid","isValidType","num","Array","isArray","every","e","Number","isNaN","nextInvocationDate","base","next","_nextInvocationDate","toDate","Date","now","tz","fullYear","getFullYear","addSecond","recurMatch","addYear","setMonth","setDate","setHours","setMinutes","setSeconds","getMonth","addMonth","getDate","addDay","getDay","getHours","addHour","getMinutes","addMinute","getSeconds","matcher","length","runOnDate","then","setTimeout","scheduleInvocation","invocation","add","prepareNextInvocation","emit","clearTimeout","cinv","currentInvocationFinished","callback","_endDate","inv","scheduleNextRecurrence","trackInvocation","stopTrackingInvocation","result","invoke","running","Promise","value","catch","err","isOneTimeJob","deleteFromSchedule","shift","cancelInvocation","idx","indexOf","splice","rule","prevDate","module","exports","_invocations"],"sources":["D:/Other Files/tktnew/eMandate/client/node_modules/node-schedule/lib/Invocation.js"],"sourcesContent":["'use strict';\n\nconst lt = require('long-timeout')\nconst CronDate = require('cron-parser/lib/date')\nconst sorted = require('sorted-array-functions')\n\nconst invocations = [];\nlet currentInvocation = null;\n\n/* DoesntRecur rule */\nconst DoesntRecur = new RecurrenceRule();\nDoesntRecur.recurs = false;\n\n/* Invocation object */\nfunction Invocation(job, fireDate, recurrenceRule, endDate) {\n  this.job = job;\n  this.fireDate = fireDate;\n  this.endDate = endDate;\n  this.recurrenceRule = recurrenceRule || DoesntRecur;\n\n  this.timerID = null;\n}\n\nfunction sorter(a, b) {\n  return (a.fireDate.getTime() - b.fireDate.getTime());\n}\n\n/* Range object */\nfunction Range(start, end, step) {\n  this.start = start || 0;\n  this.end = end || 60;\n  this.step = step || 1;\n}\n\nRange.prototype.contains = function(val) {\n  if (this.step === null || this.step === 1) {\n    return (val >= this.start && val <= this.end);\n  } else {\n    for (let i = this.start; i < this.end; i += this.step) {\n      if (i === val) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n};\n\n/* RecurrenceRule object */\n/*\n  Interpreting each property:\n  null - any value is valid\n  number - fixed value\n  Range - value must fall in range\n  array - value must validate against any item in list\n\n  NOTE: Cron months are 1-based, but RecurrenceRule months are 0-based.\n*/\nfunction RecurrenceRule(year, month, date, dayOfWeek, hour, minute, second) {\n  this.recurs = true;\n\n  this.year = (year == null) ? null : year;\n  this.month = (month == null) ? null : month;\n  this.date = (date == null) ? null : date;\n  this.dayOfWeek = (dayOfWeek == null) ? null : dayOfWeek;\n  this.hour = (hour == null) ? null : hour;\n  this.minute = (minute == null) ? null : minute;\n  this.second = (second == null) ? 0 : second;\n}\n\nRecurrenceRule.prototype.isValid = function() {\n  function isValidType(num) {\n    if (Array.isArray(num) || (num instanceof Array)) {\n      return num.every(function(e) {\n        return isValidType(e);\n      });\n    }\n    return !(Number.isNaN(Number(num)) && !(num instanceof Range));\n  }\n  if (this.month !== null && (this.month < 0 || this.month > 11 || !isValidType(this.month))) {\n    return false;\n  }\n  if (this.dayOfWeek !== null && (this.dayOfWeek < 0 || this.dayOfWeek > 6 || !isValidType(this.dayOfWeek))) {\n    return false;\n  }\n  if (this.hour !== null && (this.hour < 0 || this.hour > 23 || !isValidType(this.hour))) {\n    return false;\n  }\n  if (this.minute !== null && (this.minute < 0 || this.minute > 59 || !isValidType(this.minute))) {\n    return false;\n  }\n  if (this.second !== null && (this.second < 0 || this.second > 59 || !isValidType(this.second))) {\n    return false;\n  }\n  if (this.date !== null) {\n    if(!isValidType(this.date)) {\n      return false;\n    }\n    switch (this.month) {\n      case 3:\n      case 5:\n      case 8:\n      case 10:\n        if (this.date < 1 || this. date > 30) {\n          return false;\n        }\n        break;\n      case 1:\n        if (this.date < 1 || this. date > 29) {\n          return false;\n        }\n        break;\n      default:\n        if (this.date < 1 || this. date > 31) {\n          return false;\n        }\n    }\n  }\n  return true;\n};\n\nRecurrenceRule.prototype.nextInvocationDate = function(base) {\n  const next = this._nextInvocationDate(base);\n  return next ? next.toDate() : null;\n};\n\nRecurrenceRule.prototype._nextInvocationDate = function(base) {\n  base = ((base instanceof CronDate) || (base instanceof Date)) ? base : (new Date());\n  if (!this.recurs) {\n    return null;\n  }\n\n  if(!this.isValid()) {\n    return null;\n  }\n\n  const now = new CronDate(Date.now(), this.tz);\n  let fullYear = now.getFullYear();\n  if ((this.year !== null) &&\n    (typeof this.year == 'number') &&\n    (this.year < fullYear)) {\n    return null;\n  }\n\n  let next = new CronDate(base.getTime(), this.tz);\n  next.addSecond();\n\n  while (true) {\n    if (this.year !== null) {\n      fullYear = next.getFullYear();\n      if ((typeof this.year == 'number') && (this.year < fullYear)) {\n        next = null;\n        break;\n      }\n\n      if (!recurMatch(fullYear, this.year)) {\n        next.addYear();\n        next.setMonth(0);\n        next.setDate(1);\n        next.setHours(0);\n        next.setMinutes(0);\n        next.setSeconds(0);\n        continue;\n      }\n    }\n    if (this.month != null && !recurMatch(next.getMonth(), this.month)) {\n      next.addMonth();\n      continue;\n    }\n    if (this.date != null && !recurMatch(next.getDate(), this.date)) {\n      next.addDay();\n      continue;\n    }\n    if (this.dayOfWeek != null && !recurMatch(next.getDay(), this.dayOfWeek)) {\n      next.addDay();\n      continue;\n    }\n    if (this.hour != null && !recurMatch(next.getHours(), this.hour)) {\n      next.addHour();\n      continue;\n    }\n    if (this.minute != null && !recurMatch(next.getMinutes(), this.minute)) {\n      next.addMinute();\n      continue;\n    }\n    if (this.second != null && !recurMatch(next.getSeconds(), this.second)) {\n      next.addSecond();\n      continue;\n    }\n\n    break;\n  }\n\n  return next;\n};\n\nfunction recurMatch(val, matcher) {\n  if (matcher == null) {\n    return true;\n  }\n\n  if (typeof matcher === 'number') {\n    return (val === matcher);\n  } else if(typeof matcher === 'string') {\n    return (val === Number(matcher));\n  } else if (matcher instanceof Range) {\n    return matcher.contains(val);\n  } else if (Array.isArray(matcher) || (matcher instanceof Array)) {\n    for (let i = 0; i < matcher.length; i++) {\n      if (recurMatch(val, matcher[i])) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/* Date-based scheduler */\nfunction runOnDate(date, job) {\n  const now = Date.now();\n  const then = date.getTime();\n\n  return lt.setTimeout(function() {\n    if (then > Date.now())\n      runOnDate(date, job);\n    else\n      job();\n  }, (then < now ? 0 : then - now));\n}\n\nfunction scheduleInvocation(invocation) {\n  sorted.add(invocations, invocation, sorter);\n  prepareNextInvocation();\n  const date = invocation.fireDate instanceof CronDate ? invocation.fireDate.toDate() : invocation.fireDate;\n  invocation.job.emit('scheduled', date);\n}\n\nfunction prepareNextInvocation() {\n  if (invocations.length > 0 && currentInvocation !== invocations[0]) {\n    if (currentInvocation !== null) {\n      lt.clearTimeout(currentInvocation.timerID);\n      currentInvocation.timerID = null;\n      currentInvocation = null;\n    }\n\n    currentInvocation = invocations[0];\n\n    const job = currentInvocation.job;\n    const cinv = currentInvocation;\n    currentInvocation.timerID = runOnDate(currentInvocation.fireDate, function() {\n      currentInvocationFinished();\n\n      if (job.callback) {\n        job.callback();\n      }\n\n      if (cinv.recurrenceRule.recurs || cinv.recurrenceRule._endDate === null) {\n        const inv = scheduleNextRecurrence(cinv.recurrenceRule, cinv.job, cinv.fireDate, cinv.endDate);\n        if (inv !== null) {\n          inv.job.trackInvocation(inv);\n        }\n      }\n\n      job.stopTrackingInvocation(cinv);\n\n      try {\n        const result = job.invoke(cinv.fireDate instanceof CronDate ? cinv.fireDate.toDate() : cinv.fireDate);\n        job.emit('run');\n        job.running += 1;\n\n        if (result instanceof Promise) {\n          result.then(function (value) {\n            job.emit('success', value);\n            job.running -= 1;\n          }).catch(function (err) {\n            job.emit('error', err);\n            job.running -= 1;\n          });\n        } else {\n          job.emit('success', result);\n          job.running -= 1;\n        }\n      } catch (err) {\n        job.emit('error', err);\n        job.running -= 1;\n      }\n\n      if (job.isOneTimeJob) {\n        job.deleteFromSchedule();\n      }\n    });\n  }\n}\n\nfunction currentInvocationFinished() {\n  invocations.shift();\n  currentInvocation = null;\n  prepareNextInvocation();\n}\n\nfunction cancelInvocation(invocation) {\n  const idx = invocations.indexOf(invocation);\n  if (idx > -1) {\n    invocations.splice(idx, 1);\n    if (invocation.timerID !== null) {\n      lt.clearTimeout(invocation.timerID);\n    }\n\n    if (currentInvocation === invocation) {\n      currentInvocation = null;\n    }\n\n    invocation.job.emit('canceled', invocation.fireDate);\n    prepareNextInvocation();\n  }\n}\n\n/* Recurrence scheduler */\nfunction scheduleNextRecurrence(rule, job, prevDate, endDate) {\n\n  prevDate = (prevDate instanceof CronDate) ? prevDate : new CronDate();\n\n  const date = (rule instanceof RecurrenceRule) ? rule._nextInvocationDate(prevDate) : rule.next();\n  if (date === null) {\n    return null;\n  }\n\n  if ((endDate instanceof CronDate) && date.getTime() > endDate.getTime()) {\n    return null;\n  }\n\n  const inv = new Invocation(job, date, rule, endDate);\n  scheduleInvocation(inv);\n\n  return inv;\n}\n\nmodule.exports = {\n  Range,\n  RecurrenceRule,\n  Invocation,\n  cancelInvocation,\n  scheduleInvocation,\n  scheduleNextRecurrence,\n  sorter,\n  _invocations: invocations\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}